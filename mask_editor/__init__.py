#!/usr/bin/env python3"""Mask Editor - FLIKA PluginInteractive mask editor for drawing, erasing, and modifying binary mask stacks.Author: George DickinsonVersion: 1.3.0"""import numpy as npfrom qtpy import QtWidgets, QtCore, QtGuifrom skimage import drawimport tifffile# FLIKA importsfrom flika import global_vars as gfrom flika.window import Windowfrom flika.utils.misc import save_file_gui# Import BaseProcess based on FLIKA versionfrom distutils.version import StrictVersionimport flikaflika_version = flika.__version__if StrictVersion(flika_version) < StrictVersion('0.2.23'):    from flika.process.BaseProcess import BaseProcess_noPriorWindow, WindowSelectorelse:    from flika.utils.BaseProcess import BaseProcess_noPriorWindow, WindowSelector__version__ = '1.3.0'class MaskEditor(BaseProcess_noPriorWindow):    """    Interactive mask editor with drawing tools.    Select a mask window, then use the editor panel to draw, erase, and modify masks.    Click and drag on the mask window to draw/erase with the selected tool.    """    def __init__(self):        super().__init__()        self.mask_window = None        self.current_tool = 'draw'        self.brush_size = 5        self.drawing = False        self.last_point = None        self.undo_stack = []        self.redo_stack = []        self.max_undo = 20        self.editor_window = None    def __call__(self, mask_window, keepSourceWindow=False):        """        Launch the mask editor with the selected window.        Parameters        ----------        mask_window : Window            The mask window to edit        """        if mask_window is None:            g.alert("Please select a mask window")            return None        # Set the mask window        self.set_mask_window(mask_window)        # Create and show the editor control panel        if self.editor_window is None or not self.editor_window.isVisible():            self.editor_window = MaskEditorPanel(self)            self.editor_window.show()        return mask_window    def set_mask_window(self, window):        """Connect to a mask window for editing."""        if self.mask_window is not None:            # Disconnect old window            try:                self.mask_window.imageview.scene.sigMouseMoved.disconnect(self.mouse_moved)                self.mask_window.imageview.keyPressEvent = None                self.mask_window.imageview.keyReleaseEvent = None            except:                pass        self.mask_window = window        # Clear undo/redo stacks        self.undo_stack = []        self.redo_stack = []        if window is not None:            # Connect mouse movement (for drawing while key is held)            window.imageview.scene.sigMouseMoved.connect(self.mouse_moved)            # Connect keyboard events            window.imageview.keyPressEvent = self.key_pressed            window.imageview.keyReleaseEvent = self.key_released            # Make sure the imageview can receive keyboard focus            window.imageview.setFocusPolicy(QtCore.Qt.StrongFocus)            window.imageview.setFocus()            # Update window info in editor if it exists            if self.editor_window is not None:                self.editor_window.update_window_info()    def mouse_moved(self, pos):        """Handle mouse movement over mask window."""        if self.drawing and self.mask_window is not None:            # Get image coordinates and swap x/y to fix reversed axes            mouse_point = self.mask_window.imageview.getImageItem().mapFromScene(pos)            y, x = int(mouse_point.x()), int(mouse_point.y())            if self.last_point is not None:                self.draw_line(self.last_point, (x, y))            else:                # First point when key is pressed                self.draw_point(x, y)            self.last_point = (x, y)    def key_pressed(self, ev):        """Handle key press events on mask window."""        if self.mask_window is None:            return        key = ev.key()        # D key for draw, E key for erase        if key == QtCore.Qt.Key_D:            if not self.drawing:                self.drawing = True                self.current_tool = 'draw'                self.save_undo_state()                self.last_point = None        elif key == QtCore.Qt.Key_E:            if not self.drawing:                self.drawing = True                self.current_tool = 'erase'                self.save_undo_state()                self.last_point = None        # Left/Right arrow keys for frame navigation        elif key == QtCore.Qt.Key_Left:            # Move to previous frame            current_frame = self.mask_window.currentIndex            if current_frame > 0:                self.mask_window.setIndex(current_frame - 1)        elif key == QtCore.Qt.Key_Right:            # Move to next frame            current_frame = self.mask_window.currentIndex            if current_frame < self.mask_window.mt - 1:                self.mask_window.setIndex(current_frame + 1)        ev.accept()    def key_released(self, ev):        """Handle key release events on mask window."""        key = ev.key()        # Stop drawing when D or E key is released        if key == QtCore.Qt.Key_D or key == QtCore.Qt.Key_E:            self.drawing = False            self.last_point = None        ev.accept()    def get_brush_radius(self):        """Convert brush size (diameter) to radius for draw.disk.        Since draw.disk uses radius, we need to convert the slider value        (which represents diameter) to radius.        """        return max(0, (self.brush_size+1) // 2)    def preserve_view_state(self, func):        """Decorator-like function to preserve view state (zoom/pan) during image updates."""        if self.mask_window is None:            return        # Get current view range        view_box = self.mask_window.imageview.getView()        view_range = view_box.viewRange()        # Execute the function        func()        # Restore frame index and view range        self.mask_window.setIndex(current_frame)        view_box.setRange(xRange=view_range[0], yRange=view_range[1], padding=0)    def update_image_preserving_view(self):        """Update the image display while preserving zoom and pan."""        if self.mask_window is None:            return        # Get current view range        view_box = self.mask_window.imageview.getView()        view_range = view_box.viewRange()        current_frame = self.mask_window.currentIndex        # Update image        self.mask_window.imageview.setImage(self.mask_window.image, autoLevels=False)        # Restore frame index and view range        self.mask_window.setIndex(current_frame)        view_box.setRange(xRange=view_range[0], yRange=view_range[1], padding=0)    def draw_point(self, x, y):        """Draw a single point on the mask."""        if self.mask_window is None:            return        current_frame = self.mask_window.currentIndex        mask = self.mask_window.image[current_frame].copy()        # Create circular brush using radius calculated from diameter        brush_radius = self.get_brush_radius()        rr, cc = draw.disk((y, x), brush_radius, shape=mask.shape)        if self.current_tool == 'draw':            mask[rr, cc] = 255        elif self.current_tool == 'erase':            mask[rr, cc] = 0        self.mask_window.image[current_frame] = mask        self.update_image_preserving_view()    def draw_line(self, start, end):        """Draw a line between two points."""        if self.mask_window is None:            return        current_frame = self.mask_window.currentIndex        mask = self.mask_window.image[current_frame].copy()        # Get line coordinates        rr, cc = draw.line(start[1], start[0], end[1], end[0])        # Draw with brush radius calculated from diameter        brush_radius = self.get_brush_radius()        for r, c in zip(rr, cc):            rr_disk, cc_disk = draw.disk((r, c), brush_radius, shape=mask.shape)            if self.current_tool == 'draw':                mask[rr_disk, cc_disk] = 255            elif self.current_tool == 'erase':                mask[rr_disk, cc_disk] = 0        self.mask_window.image[current_frame] = mask        self.update_image_preserving_view()    def save_undo_state(self):        """Save current state for undo."""        if self.mask_window is None:            return        current_frame = self.mask_window.currentIndex        state = self.mask_window.image[current_frame].copy()        self.undo_stack.append((current_frame, state))        # Clear redo stack when new action is performed        self.redo_stack = []        # Limit undo stack size        if len(self.undo_stack) > self.max_undo:            self.undo_stack.pop(0)        # Update button states in editor panel        if self.editor_window is not None:            self.editor_window.update_undo_redo_buttons()    def undo(self):        """Undo last edit."""        if len(self.undo_stack) > 0:            # Save current state to redo stack            current_frame = self.mask_window.currentIndex            current_state = self.mask_window.image[current_frame].copy()            # Get previous state            frame_idx, state = self.undo_stack.pop()            self.redo_stack.append((frame_idx, current_state))            # Restore previous state            self.mask_window.image[frame_idx] = state            self.mask_window.setIndex(frame_idx)            self.update_image_preserving_view()            # Update button states in editor panel            if self.editor_window is not None:                self.editor_window.update_undo_redo_buttons()    def redo(self):        """Redo last undone edit."""        if len(self.redo_stack) > 0:            # Save current state to undo stack            current_frame = self.mask_window.currentIndex            current_state = self.mask_window.image[current_frame].copy()            # Get redo state            frame_idx, state = self.redo_stack.pop()            self.undo_stack.append((frame_idx, current_state))            # Restore redo state            self.mask_window.image[frame_idx] = state            self.mask_window.setIndex(frame_idx)            self.update_image_preserving_view()            # Update button states in editor panel            if self.editor_window is not None:                self.editor_window.update_undo_redo_buttons()    def gui(self):        """Setup the parameter selection GUI using BaseProcess framework."""        self.gui_reset()        mask_window_selector = WindowSelector()        self.items.append({'name': 'mask_window',                          'string': 'Select Mask Window to Edit',                          'object': mask_window_selector})        super().gui()class MaskEditorPanel(QtWidgets.QWidget):    """Control panel for mask editing tools."""    def __init__(self, mask_editor, parent=None):        super().__init__(parent)        self.mask_editor = mask_editor        self.initUI()        self.setWindowTitle("Mask Editor Controls")        self.resize(500, 650)    def initUI(self):        """Initialize the user interface."""        layout = QtWidgets.QVBoxLayout()        # Title        title = QtWidgets.QLabel("<h2>üé® Mask Editor Controls</h2>")        title.setAlignment(QtCore.Qt.AlignCenter)        layout.addWidget(title)        # Window info        self.window_info_label = QtWidgets.QLabel("No window selected")        self.window_info_label.setStyleSheet(            "QLabel { background-color: #f0f0f0; padding: 10px; border-radius: 5px; }")        layout.addWidget(self.window_info_label)        # Update window info        self.update_window_info()        # Frame tools (no draw/erase buttons since we use keyboard)        tool_group = QtWidgets.QGroupBox("Frame Tools")        tool_layout = QtWidgets.QGridLayout()        self.fill_btn = QtWidgets.QPushButton("ü™£ Fill Frame")        self.fill_btn.clicked.connect(self.fill_mask)        self.clear_btn = QtWidgets.QPushButton("üóëÔ∏è Clear Frame")        self.clear_btn.clicked.connect(self.clear_frame)        tool_layout.addWidget(self.fill_btn, 0, 0)        tool_layout.addWidget(self.clear_btn, 0, 1)        tool_group.setLayout(tool_layout)        layout.addWidget(tool_group)        # Brush size control        brush_group = QtWidgets.QGroupBox("Brush Settings")        brush_layout = QtWidgets.QVBoxLayout()        size_layout = QtWidgets.QHBoxLayout()        size_layout.addWidget(QtWidgets.QLabel("Brush Size:"))        self.brush_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)        self.brush_slider.setMinimum(1)        self.brush_slider.setMaximum(50)        self.brush_slider.setValue(5)        self.brush_slider.valueChanged.connect(self.update_brush_size)        self.brush_label = QtWidgets.QLabel("5 px")        self.brush_label.setMinimumWidth(50)        size_layout.addWidget(self.brush_slider)        size_layout.addWidget(self.brush_label)        brush_layout.addLayout(size_layout)        brush_group.setLayout(brush_layout)        layout.addWidget(brush_group)        # Undo/Redo        undo_group = QtWidgets.QGroupBox("History")        undo_layout = QtWidgets.QHBoxLayout()        self.undo_btn = QtWidgets.QPushButton("‚Ü∂ Undo")        self.undo_btn.clicked.connect(self.undo)        self.undo_btn.setEnabled(False)        self.redo_btn = QtWidgets.QPushButton("‚Ü∑ Redo")        self.redo_btn.clicked.connect(self.redo)        self.redo_btn.setEnabled(False)        undo_layout.addWidget(self.undo_btn)        undo_layout.addWidget(self.redo_btn)        undo_group.setLayout(undo_layout)        layout.addWidget(undo_group)        # Frame operations        frame_group = QtWidgets.QGroupBox("Frame Operations")        frame_layout = QtWidgets.QGridLayout()        self.copy_next_btn = QtWidgets.QPushButton("‚û°Ô∏è Copy to Next")        self.copy_next_btn.clicked.connect(self.copy_to_next_frame)        self.copy_prev_btn = QtWidgets.QPushButton("‚¨ÖÔ∏è Copy to Previous")        self.copy_prev_btn.clicked.connect(self.copy_to_prev_frame)        self.copy_all_btn = QtWidgets.QPushButton("üìã Copy to All Frames")        self.copy_all_btn.clicked.connect(self.copy_to_all_frames)        frame_layout.addWidget(self.copy_next_btn, 0, 0)        frame_layout.addWidget(self.copy_prev_btn, 0, 1)        frame_layout.addWidget(self.copy_all_btn, 1, 0, 1, 2)        frame_group.setLayout(frame_layout)        layout.addWidget(frame_group)        # Save button        self.save_mask_btn = QtWidgets.QPushButton("üíæ Save Modified Mask")        self.save_mask_btn.clicked.connect(self.save_mask)        self.save_mask_btn.setStyleSheet("QPushButton { padding: 10px; font-weight: bold; }")        layout.addWidget(self.save_mask_btn)        # Instructions        instructions = QtWidgets.QLabel(            "<b>Keyboard Controls:</b><br>"            "‚å®Ô∏è Hold <b>D</b> key + move mouse = Draw<br>"            "‚å®Ô∏è Hold <b>E</b> key + move mouse = Erase<br>"            "‚¨ÖÔ∏è‚û°Ô∏è <b>Left/Right Arrow</b> keys = Navigate frames<br>"            "üìç Adjust brush size with the slider<br>"            "‚Ü∂ Use Undo/Redo to correct mistakes<br>"            "üíæ Save your modifications when complete<br>"            "<br>"            "<i>Note: Click on mask window first to activate keyboard controls</i>"        )        instructions.setWordWrap(True)        instructions.setStyleSheet(            "QLabel { background-color: #e8f4f8; padding: 10px; border-radius: 5px; }")        layout.addWidget(instructions)        layout.addStretch()        self.setLayout(layout)        # Update button states        self.update_undo_redo_buttons()    def update_window_info(self):        """Update the window information display."""        if self.mask_editor.mask_window is not None:            win = self.mask_editor.mask_window            self.window_info_label.setText(                f"<b>Window:</b> {win.name}<br>"                f"<b>Shape:</b> {win.mt} frames √ó {win.my} √ó {win.mx} pixels"            )        else:            self.window_info_label.setText("No window selected")    def update_brush_size(self, value):        """Update brush size from slider."""        self.mask_editor.brush_size = value        self.brush_label.setText(f"{value} px")    def fill_mask(self):        """Fill the entire current frame with mask."""        if self.mask_editor.mask_window is None:            return        self.mask_editor.save_undo_state()        current_frame = self.mask_editor.mask_window.currentIndex        self.mask_editor.mask_window.image[current_frame] = np.ones_like(            self.mask_editor.mask_window.image[current_frame]) * 255        self.mask_editor.update_image_preserving_view()        self.update_undo_redo_buttons()    def clear_frame(self):        """Clear the current frame mask."""        if self.mask_editor.mask_window is None:            return        reply = QtWidgets.QMessageBox.question(            self, 'Clear Frame',            'Clear the entire mask for this frame?',            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No        )        if reply == QtWidgets.QMessageBox.Yes:            self.mask_editor.save_undo_state()            current_frame = self.mask_editor.mask_window.currentIndex            self.mask_editor.mask_window.image[current_frame] = np.zeros_like(                self.mask_editor.mask_window.image[current_frame])            self.mask_editor.update_image_preserving_view()            self.update_undo_redo_buttons()    def copy_to_next_frame(self):        """Copy current frame mask to next frame."""        if self.mask_editor.mask_window is None:            return        current_frame = self.mask_editor.mask_window.currentIndex        if current_frame < self.mask_editor.mask_window.mt - 1:            self.mask_editor.save_undo_state()            self.mask_editor.mask_window.image[current_frame + 1] = \                self.mask_editor.mask_window.image[current_frame].copy()            self.mask_editor.mask_window.setIndex(current_frame + 1)            self.update_undo_redo_buttons()            QtWidgets.QMessageBox.information(self, 'Success', 'Mask copied to next frame')        else:            QtWidgets.QMessageBox.warning(self, 'Warning', 'Already at last frame')    def copy_to_prev_frame(self):        """Copy current frame mask to previous frame."""        if self.mask_editor.mask_window is None:            return        current_frame = self.mask_editor.mask_window.currentIndex        if current_frame > 0:            self.mask_editor.save_undo_state()            self.mask_editor.mask_window.image[current_frame - 1] = \                self.mask_editor.mask_window.image[current_frame].copy()            self.mask_editor.mask_window.setIndex(current_frame - 1)            self.update_undo_redo_buttons()            QtWidgets.QMessageBox.information(self, 'Success', 'Mask copied to previous frame')        else:            QtWidgets.QMessageBox.warning(self, 'Warning', 'Already at first frame')    def copy_to_all_frames(self):        """Copy current frame mask to all frames."""        if self.mask_editor.mask_window is None:            return        reply = QtWidgets.QMessageBox.question(            self, 'Copy to All Frames',            'Copy the current frame mask to ALL frames?\nThis will overwrite existing masks!',            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No        )        if reply == QtWidgets.QMessageBox.Yes:            self.mask_editor.save_undo_state()            current_frame = self.mask_editor.mask_window.currentIndex            current_mask = self.mask_editor.mask_window.image[current_frame].copy()            for i in range(self.mask_editor.mask_window.mt):                self.mask_editor.mask_window.image[i] = current_mask.copy()            self.mask_editor.update_image_preserving_view()            self.update_undo_redo_buttons()            QtWidgets.QMessageBox.information(                self, 'Success', f'Mask copied to all {self.mask_editor.mask_window.mt} frames')    def undo(self):        """Undo last edit."""        self.mask_editor.undo()        self.update_undo_redo_buttons()    def redo(self):        """Redo last undone edit."""        self.mask_editor.redo()        self.update_undo_redo_buttons()    def update_undo_redo_buttons(self):        """Update enabled state of undo/redo buttons."""        self.undo_btn.setEnabled(len(self.mask_editor.undo_stack) > 0)        self.redo_btn.setEnabled(len(self.mask_editor.redo_stack) > 0)    def save_mask(self):        """Save the modified mask stack."""        if self.mask_editor.mask_window is None:            return        filename = save_file_gui("Save Modified Mask", None, "*.tif")        if filename:            try:                # Ensure binary mask                mask_data = (self.mask_editor.mask_window.image > 0).astype(np.uint8) * 255                tifffile.imwrite(filename, mask_data)                QtWidgets.QMessageBox.information(                    self, 'Success', f'Mask saved to:\n{filename}')            except Exception as e:                QtWidgets.QMessageBox.critical(                    self, 'Error', f'Failed to save mask:\n{str(e)}')    def closeEvent(self, event):        """Handle window close event."""        if self.mask_editor.mask_window is not None:            try:                self.mask_editor.mask_window.imageview.scene.sigMouseMoved.disconnect(                    self.mask_editor.mouse_moved)                self.mask_editor.mask_window.imageview.keyPressEvent = None                self.mask_editor.mask_window.imageview.keyReleaseEvent = None            except:                pass        event.accept()# =============================================================================# Plugin Entry Point# =============================================================================# Create global instancemask_editor = MaskEditor()def launch_mask_editor():    """Launch the Mask Editor plugin."""    mask_editor.gui()# For FLIKA plugin systemif __name__ == '__main__':    launch_mask_editor()